DTO：Data Transfer Object：数据传输对象，用于数据传输的对象。数据库之间的表和web之间的映射用entity类来表示，他包含表中所有的字段。而前端和web端进行交互时，使用DTO对象来映射，因为传输的数据只包含一部分字段而不是所有字段，如果用entity来进行数据传输非常浪费网络资源，所以就把需要传输的字段封装成一个DTO对象用来进行前端和后端的传输。

* **DO**（Data Object）：此对象**与数据库表结构一一对**应，通过 DAO 层向上传输数据源对象。
* **DTO**（Data Transfer Object）：**数据传输对象**，Service 或 Manager 向外传输的对象。
* **BO**（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。
* **AO**（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
* **VO**（View Object）：显示层对象，通常是 **Web 向模板渲染引擎层传输的对象**。
* **Query**：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。

example类：myBatis创建的封装了sql方法的实体类

PostMan提交方式：
|post参数格式|Content-Type|参数示例|
|:--        |:--        |:--      |
|表单提交    |application/x-www-form-urlencoded|username=abc&password=123|
|Json提交   |application/json|{"username":"abc","password":"123"}
|xml提交    | text/xml  |\<?xml version="1.0" encoding="utf-8"?>\<book>book\</book>


cn.hutool 工具类
com.google.common.collect 工具类

双击shift全局搜索：查找文件名
ctrl+shift+F：在文件内容中进行搜索

redis工具类

RestTemplate类，Spring封装的进行http请求的工具类

## 在idea中使用http restful进行测试
idea的工具栏中点击tool，http client，test restful web service打开测试栏，也可以点击convert request to the new format在文本中进行编辑http请求，并保存在文件中

Spring创建的对象对象名一般为首字母大写的类名，但是如果当类名是两个或两个以上的大写字母开头的话，bean的名字会和类名保持一致。

redis中为了方便查看，通常有层级之分。使用:来区分层级之间的关系，目录和已经存在的key没有关系。例如 
```java
//在list1中添加一个值list2。此时list1为一个list
lpush list1 list2
//在list1目录下的list2中添加一个值value。此时list1为一个目录，list2为一个list
lpush list1:list2 value
//在list1目录下的list2目录下的list3中添加一个值value。此时list1、list2为一个目录，list3为list
lpush list1:list2:list3 value

```


bug：
1. 重复提交任务可以一直提交到缓存中，并且新提交的任务无bid字段。
    * 由于没有不能为空字段bid，所以取出时会报错
    * 新提交的任务放在原来的任务后面执行，是否可能出现错误？出现错误添加任务状态判断
2. 进行缓存和db同步时，添加的字段不是任务对象的json字符串而是bid字段  √
3. 公平轮询方式取任务有问题，取任务的逻辑是如果队列不为空，取第一个groupVal，但是如果该groupVal中等待队列为空，但是正在执行队列不为空，会出现错误。解决方法：取groupVal时加一个判断，如果该groupVal的等待队列为空，那么跳过获取下一个groupVal。
    * 每次取完任务之后就对等待队列的长度进行判断，如果为空那么就用lua表达式进行原子性删除，所以不存在这种情况。
4. 直接添加的数据和缓存同步之后添加的数据字段不同。