## 读写分离
读写分离就是在主服务器上修改数据，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。

由于写数据库的操作比较耗时，而读数据库的操作效率较高，所以为了避免数据库的写入影响查询的效率，要进行数据库的读写分离。

索引问题：单机情况下都会对数据库的字段添加索引，加快检索效率，但是插入时也要对索引进行更新，插入效率降低。数据库主从分离之后，可以单独的针对从库做索引上的优化，而主库可以减少索引提高写的效率。

在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。有点类似于前面我们学习过的rsync，但是不同的是rsync是对磁盘文件做备份，而mysql主从复制是对数据库中的数据、语句做备份。

## MySQL支持的复制类型
1. 基于语句的复制。在主服务器上执行sql语句，在从服务器上执行同样的语句。MySQL默认使用基于语句的复制，执行效率较高。
2. 基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。
3. 混合类型的复制。默认采用基于语句的复制，一旦发现基于语句的复制无法精确复制时，就会采用基于行的复制。

## 复制过程
1. 在每个事务更新数据完成之前，master在二进制日志记录这些改变，写入二进制日志完成后，master通知存储引擎提交事务。

2. slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。

3. Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。

## 分配机制
分配机制就是怎么制定sql写操作去主库写，读操作是从从库读。一般有两种方式实现：
1. 代码封装：代码封装的实现很简单，就是抽出一个中间层，让这个中间层来实现读写分离和数据库连接。在代码中根据select、insert对不同的dataSource进行数据库操作。
    * 优点是实现简单，性能较好，因为程序在代码中实现，不需要增加额外的硬件开支。
    * 缺点是如果一个数据库宕机了，发生了主从切换之后，就得修改配置重启。如果系统中包含多种代码的子系统，那么就需要针对不同的语言设计不同的中间件。
2. 数据库中间件：就是有一个独立的系统，专门来实现读写分离和数据库连接管理，业务服务器和数据库中间件之间是通过标准的SQL协议交流的，所以在业务服务器看来数据库中间件其实就是个数据库。
    * 优点：因为是通过sql协议交流所以兼容不同的语言，并且有中间件实现主从切换，业务服务器不需要关心这点。
    * 系统中多了一个系统，相当于多了一个瓶颈，对中间件的性能要求很高

## 读写分离的数据一致性
当主从数据库进行数据同步时，会有一定时间的延迟，解决同步延迟的问题有以下几种办法：
* 指定写操作之后的读操作访问主库，之后的操作采取访问从库，这样的话业务的耦合性比较高。
* 关键业务读写都有主库承担，非关键业务读写分离。

## 总结
读写分离相对而言是比较简单的，比分表分库简单，但是他只能**分担访问的压力，分担不了存储的压力**，也就是随着数据库表的数据逐渐增多，但是面对一张表海量的数据，查询还是很慢的，所以如果数据量非常大的话，还是要分库分表。

正常情况下，先使用单机，单机压力太大可以先进行优化，优化业务逻辑或加入缓存等，单机顶不住访问压力才使用集群，先读写分离，读写分离顶不住之后再进行分库分表。